# Set the global container repo.
repository: ghcr.io

# Set the global container repo organization.
organization: unikorn-cloud

# Set the global container tag.
# Defaults to the chart revision, which should be in lock-step with the
# actual release.
# tag:

# Set the docker configuration, doing so will create a secret and link it
# to the service accounts of all the controllers.  You can do something like:
# --set dockerConfig=$(cat ~/.docker/config.json | base64 -w0)
dockerConfig:

# Set the image pull secret on the service accounts of all the controllers.
# This is an alternative to dockerConfigs, but unlikely to play ball with
# ArgoCD as it's a foreign object that needs pruning.
imagePullSecret:

# Project manager specific configuration.
projectManager:
  # Allows override of the global default image.
  image:

# Control plane manager specific configuration.
controlPlaneManager:
  # Allows override of the global default image.
  image:

# Cluster manager specific configuration.
clusterManager:
  # Allows override of the global default image.
  image:

# Monitor specific configuration.
monitor:
  # Allows override of the global default image.
  image:

# REST server specific configuration.
server:
  # Temporarily block deployment until it's complete.
  enabled: false

  # Allows override of the global default image.
  image:

  # Define the cloud provider credentials.
  provider:
    # OpenStack is an open-source cloud solution, allowing on-premise
    # deployments of public or private clouds.
    openstack:
      # The Keystone service endpoint.
      endpoint: https://openstack.acme.com

      # Defines the service account credentials.  Unikorn uses federated
      # identity via OIDC, and while OpenStack can be configured to do so
      # we use application credentials to allow clusters to self manage.
      # OpenStack does not allow federated application credentials because
      # it cannot know when a user is revoked and propagate this to an
      # application credential.
      serviceAccount:
        # The secret must exist in the same namespace as Unikorn, and contain
        # the key applicationcredentialid (as this is globally unique) and secret.
        # This must be a full admin account in order to provision projects and
        # other RBAC related items, and be unrestricted so it can create other
        # application credentials for individual clusters under management.
        secret:
          name: openstack-applicationcredential

      identity:
        # Define the roles that are required for Cluster API to function
        # correctly, typically this will include compute, networking and
        # LBaaS.
        applicationCredentialRoles:
        - member
        - load-balancer_member

      compute:
        # Unikorn uses OpenStack anti-affinity rules to provision Kubernetes
        # control plane nodes as Cluster API is awful and yields broken clusters.
        serverGroupPolicy: soft-anti-affinity

        # # Allows filtering of flavors with defined properties.
        # flavorPropertiesExclude:
        # - resources:CUSTOM_BAREMETAL

        # Allows GPU metadata to be extracted from the flavor extra specs.
        # If the property exists, then apply the expression to extract the number
        # of GPUs.
        flavorGpuDescriptors:
        - property: resources:PGPU
          expression: ^(\d+)$
        - property: resources:VGPU
          expression: ^(\d+)$

      # image:
      #   # If defined this will filter compute images based on whether all the
      #   # given properies exist on an image.  One particular use that is hightly
      #   # recommended is to use the property "k8s" that defines the preinstalled
      #   # version of Kubernetes to improve cluster provisioning time.
      #   # properties:
      #   - k8s
      #
      #   # If defined this will filter compute images based on whether or not
      #   # the image is signed by an external authority.  This is userful on
      #   # multi tenant clouds where other non-unikorn images may exist.
      #   # Signatures are attached to an image via the "digest" metadata property
      #   # and the value is a base64 encoded ECDSA hash over the image ID, that
      #   # cannot be manually overriden by a user in order to resuse an existing
      #   # signature.  Public key types other that eliptic curve are not currently
      #   # supported.
      #   signingKey: ~

  ingress:
    # Sets the ingress class to use.
    ingressClass: nginx

    # A map of explicit annotations to add to the ingress.  By default, when not
    # specified, the chart will create an issuer and add in an annotation to generate
    # self signed TLS secret with cert-manager.  For real life deployments, you will
    # want something like the following e.g. a shared cluster issuer, and external-dns
    # to define the DNS address via DDNS and keep the IP address in sync.
    # annotations:
    #   external-dns.alpha.kubernetes.io/hostname=unikorn.unikorn-cloud.org
    #   cert-manager.io/issuer: letsencrypt-prod

    # Sets the DNS hosts/X.509 Certs.
    host: unikorn.unikorn-cloud.org

  oidc:
    # OIDC issuer used to discover OIDC configuration and verify access tokens.
    issuer: https://identity.unikorn-cloud.org

    # CA certificate to use to verify connections to the issuer, used in development only.
    # This is a base64 encoded PEM file.
    # issuerCA:

  # Sets the OTLP endpoint for shipping spans.
  # otlpEndpoint: jaeger-collector.default:4318

# UI that works with the server.
ui:
  # Temporarily block deployment until it's complete.
  enabled: false

# Defines Prometheus monitoring integration.
monitoring:
  # Enable monitoring, ensure Prometheus is installed first to define the CRDs.
  enabled: false

  # Set the namespace to generate the service monitor into.
  namespace: monitoring

  # Define service monitor configuration.
  serviceMonitor:

    # Labels required to be selected by Prometheus, this is compatible with
    # kube-prometheus defaults.
    labels:
      release: prometheus
